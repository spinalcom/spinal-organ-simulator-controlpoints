"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalEnvViewerGraphService = require("spinal-env-viewer-graph-service");

var _spinalModelsBuildingElements = require("spinal-models-building-elements");

var _constants = require("./constants");

var constants = _interopRequireWildcard(_constants);

var _spinalCoreConnectorjs_type = require("spinal-core-connectorjs_type");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Copyright 2020 SpinalCom - www.spinalcom.com
 *
 * This file is part of SpinalCore.
 *
 * Please read all of the following terms and conditions
 * of the Free Software license Agreement ("Agreement")
 * carefully.
 *
 * This Agreement is a legally binding contract between
 * the Licensee (as defined below) and SpinalCom that
 * sets forth the terms and conditions that govern your
 * use of the Program. By installing and/or using the
 * Program, you agree to abide by all the terms and
 * conditions stated or referenced herein.
 *
 * If you do not agree to abide by these terms and
 * conditions, do not demonstrate your acceptance and do
 * not install or use the Program.
 * You should have received a copy of the license along
 * with this file. If not, see
 * <http://resources.spinalcom.com/licenses.pdf>.
 */

const GeographicContext = {
  constants: constants,

  /**
   * Returns the child type of the type given as parameter.
   * @param {string} parentType
   * @return {string} Child type
   */
  getChildType(parentType) {
    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);

    if (parentTypeIndex === -1) {
      return "";
    }

    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];
  },

  /**
   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.
   * @param {string} contextName
   * @returns {Boolean}
   */
  createContext(contextName) {
    if (typeof contextName !== "string") {
      throw Error("contextName must be a string");
    }

    const context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);

    if (typeof context !== "undefined") return Promise.resolve(context);

    return _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, constants.CONTEXT_TYPE, new _spinalModelsBuildingElements.AbstractElement(contextName));
  },

  /**
   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} elementName - The AbstactElement Name
   * @returns {Boolean}
   */
  addAbstractElement(context, node, elementName) {
    const parentType = node.type.get();
    const childType = this.getChildType(parentType);

    if (!childType) {
      throw Error(`${parentType} is not a valid type in geographic context`);
    }

    const childRelation = constants.MAP_TYPE_RELATION.get(childType);

    const childNode = _spinalEnvViewerGraphService.SpinalGraphService.createNode({ name: elementName, type: childType }, new _spinalModelsBuildingElements.AbstractElement(elementName));
    _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id.get(), childRelation, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);

    this.addToReferenceContext(childNode);

    return true;
  },

  /**
   * @param {string} contextId - The Context geographic Id
   * @param {string} parentId - The parent Node Id
   * @param {string} buildingName - Building Name
   */
  addBuilding(contextId, parentId, buildingName) {

    let nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: buildingName,
      type: constants.BUILDING_TYPE
    }, new _spinalModelsBuildingElements.AbstractElement(buildingName));

    this.addToReferenceContext(nodeId);

    return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(parentId, nodeId, contextId, constants.BUILDING_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
  },

  /**
   * @param {string} contextId - The Context geographic Id
   * @param {string} parentId - The parent Node Id
   * @param {string} floorName - the floor Name
   */
  addFloor(contextId, parentId, floorName) {
    let nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: floorName,
      type: constants.FLOOR_TYPE
    }, new _spinalModelsBuildingElements.AbstractElement(floorName));

    this.addToReferenceContext(nodeId);

    return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(parentId, nodeId, contextId, constants.FLOOR_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
  },

  /**
   * @param {string} contextId - The Context geographic Id
   * @param {string} parentId - The parent Node Id
   * @param {string} siteName - the site Name
   */
  addSite(contextId, parentId, siteName) {

    let nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: siteName,
      type: constants.SITE_TYPE
    }, new _spinalModelsBuildingElements.AbstractElement(siteName));

    this.addToReferenceContext(nodeId);

    return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(parentId, nodeId, contextId, constants.SITE_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
  },

  /**
   * @param {string} contextId - The Context geographic Id
   * @param {string} parentId - The parent Node Id
   * @param {string} zoneName - Zone name
   */
  addZone(contextId, parentId, zoneName) {
    let nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: zoneName,
      type: constants.ZONE_TYPE
    }, new _spinalModelsBuildingElements.AbstractElement(zoneName));

    this.addToReferenceContext(nodeId);

    return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(parentId, nodeId, contextId, constants.ZONE_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
  },

  /**
   * @param {string} contextId - The Context geographic
   * @param {string} parentId - The parent Node
   * @param {string} roomName - Room Name
   */
  addRoom(contextId, parentId, roomName) {
    let nodeId = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: roomName,
      type: constants.ROOM_TYPE
    }, new _spinalModelsBuildingElements.AbstractElement(roomName));

    this.addToReferenceContext(nodeId);

    return _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(parentId, nodeId, contextId, constants.ROOM_RELATION, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
  },

  /**
   * it uses bimObject service to add all dbIds passed as parameters.
   * the parameter dbIds can be a simple dbIds or a list of dbIds.
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {Number | Array<Number>} dbIds - Can be
   */
  addBimElement(context, node, dbIds, model) {

    if (!Array.isArray(dbIds)) dbIds = [dbIds];

    // le bimObjectService
    // let c = SpinalGraphService.getRealNode(context.id.get());
    // let n = SpinalGraphService.getRealNode(node.id.get());

    let contextId = context.id.get();
    let parentId = node.id.get();

    dbIds.forEach(element => {
      // bimobjService.addBIMObject(c, n, element.dbId, element.name);
      window.spinal.BimObjectService.addBIMObject(contextId, parentId, element.dbId, element.name, model);
    });
  },

  _getReferenceContextName(nodeId) {
    let node = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId);

    switch (node.type.get()) {
      case constants.SITE_TYPE:
        return {
          name: constants.SITE_REFERENCE_CONTEXT,
          relation: constants.SITE_RELATION
        };
      case constants.BUILDING_TYPE:
        return {
          name: constants.BUILDING_REFERENCE_CONTEXT,
          relation: constants.BUILDING_RELATION
        };

      case constants.FLOOR_TYPE:
        return {
          name: constants.FLOOR_REFERENCE_CONTEXT,
          relation: constants.FLOOR_RELATION
        };

      case constants.ZONE_TYPE:
        return {
          name: constants.ZONE_REFERENCE_CONTEXT,
          relation: constants.ZONE_RELATION
        };

      case constants.ROOM_TYPE:
        return {
          name: constants.ROOM_REFERENCE_CONTEXT,
          relation: constants.ROOM_RELATION
        };

      default:
        return undefined;
    }
  },

  /**
   *
   * @param {string} nodeId
   */
  addToReferenceContext(nodeId) {
    let obj = this._getReferenceContextName(nodeId);

    if (typeof obj !== "undefined") {
      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(obj.name);

      if (typeof context !== "undefined") {
        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(context.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
      }

      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(obj.name, obj.name.replace(".", ""), new _spinalCoreConnectorjs_type.Model({ name: obj.name })).then(c => {
        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(c.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_PTR_LST_TYPE);
      });
    }
  },

  /**
   *
   * @param {string} contextId
   */
  addContextToReference(contextId) {
    let context = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(contextId);

    if (typeof context !== "undefined") {
      return context.forEach(constants.GEOGRAPHIC_RELATIONS, node => {
        _spinalEnvViewerGraphService.SpinalGraphService._addNode(node);
        this.addToReferenceContext(node.info.id.get());
      });
    }
  }

};

exports.default = GeographicContext;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJHZW9ncmFwaGljQ29udGV4dCIsImdldENoaWxkVHlwZSIsInBhcmVudFR5cGUiLCJwYXJlbnRUeXBlSW5kZXgiLCJHRU9HUkFQSElDX1RZUEVTX09SREVSIiwiaW5kZXhPZiIsImNyZWF0ZUNvbnRleHQiLCJjb250ZXh0TmFtZSIsIkVycm9yIiwiY29udGV4dCIsIlNwaW5hbEdyYXBoU2VydmljZSIsImdldENvbnRleHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImFkZENvbnRleHQiLCJDT05URVhUX1RZUEUiLCJBYnN0cmFjdEVsZW1lbnQiLCJhZGRBYnN0cmFjdEVsZW1lbnQiLCJub2RlIiwiZWxlbWVudE5hbWUiLCJ0eXBlIiwiZ2V0IiwiY2hpbGRUeXBlIiwiY2hpbGRSZWxhdGlvbiIsIk1BUF9UWVBFX1JFTEFUSU9OIiwiY2hpbGROb2RlIiwiY3JlYXRlTm9kZSIsIm5hbWUiLCJhZGRDaGlsZEluQ29udGV4dCIsImlkIiwiU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSIsImFkZFRvUmVmZXJlbmNlQ29udGV4dCIsImFkZEJ1aWxkaW5nIiwiY29udGV4dElkIiwicGFyZW50SWQiLCJidWlsZGluZ05hbWUiLCJub2RlSWQiLCJCVUlMRElOR19UWVBFIiwiQlVJTERJTkdfUkVMQVRJT04iLCJhZGRGbG9vciIsImZsb29yTmFtZSIsIkZMT09SX1RZUEUiLCJGTE9PUl9SRUxBVElPTiIsImFkZFNpdGUiLCJzaXRlTmFtZSIsIlNJVEVfVFlQRSIsIlNJVEVfUkVMQVRJT04iLCJhZGRab25lIiwiem9uZU5hbWUiLCJaT05FX1RZUEUiLCJaT05FX1JFTEFUSU9OIiwiYWRkUm9vbSIsInJvb21OYW1lIiwiUk9PTV9UWVBFIiwiUk9PTV9SRUxBVElPTiIsImFkZEJpbUVsZW1lbnQiLCJkYklkcyIsIm1vZGVsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsImVsZW1lbnQiLCJ3aW5kb3ciLCJzcGluYWwiLCJCaW1PYmplY3RTZXJ2aWNlIiwiYWRkQklNT2JqZWN0IiwiZGJJZCIsIl9nZXRSZWZlcmVuY2VDb250ZXh0TmFtZSIsImdldEluZm8iLCJTSVRFX1JFRkVSRU5DRV9DT05URVhUIiwicmVsYXRpb24iLCJCVUlMRElOR19SRUZFUkVOQ0VfQ09OVEVYVCIsIkZMT09SX1JFRkVSRU5DRV9DT05URVhUIiwiWk9ORV9SRUZFUkVOQ0VfQ09OVEVYVCIsIlJPT01fUkVGRVJFTkNFX0NPTlRFWFQiLCJ1bmRlZmluZWQiLCJvYmoiLCJhZGRDaGlsZCIsImluZm8iLCJyZXBsYWNlIiwiTW9kZWwiLCJ0aGVuIiwiYyIsImFkZENvbnRleHRUb1JlZmVyZW5jZSIsImdldFJlYWxOb2RlIiwiR0VPR1JBUEhJQ19SRUxBVElPTlMiLCJfYWRkTm9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBd0JBOztBQUlBOztBQUVBOztJQUFZQSxTOztBQUNaOzs7O0FBL0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0EsTUFBTUMsb0JBQW9CO0FBQ3hCRCxhQUFXQSxTQURhOztBQUd4Qjs7Ozs7QUFLQUUsZUFBYUMsVUFBYixFQUF5QjtBQUN2QixRQUFJQyxrQkFBa0JKLFVBQVVLLHNCQUFWLENBQWlDQyxPQUFqQyxDQUNwQkgsVUFEb0IsQ0FBdEI7O0FBR0EsUUFBSUMsb0JBQW9CLENBQUMsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxFQUFQO0FBQ0Q7O0FBRUQsV0FBT0osVUFBVUssc0JBQVYsQ0FBaUNELGtCQUFrQixDQUFuRCxDQUFQO0FBQ0QsR0FqQnVCOztBQW1CeEI7Ozs7O0FBS0FHLGdCQUFjQyxXQUFkLEVBQTJCO0FBQ3pCLFFBQUksT0FBT0EsV0FBUCxLQUF1QixRQUEzQixFQUFxQztBQUNuQyxZQUFNQyxNQUNKLDhCQURJLENBQU47QUFFRDs7QUFFRCxVQUFNQyxVQUFVQyxnREFBbUJDLFVBQW5CLENBQThCSixXQUE5QixDQUFoQjs7QUFFQSxRQUFJLE9BQU9FLE9BQVAsS0FBbUIsV0FBdkIs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RSxRQUFuQixDQUE0QnBFLElBQTVCO0FBQ0EsYUFBS2EscUJBQUwsQ0FBMkJiLEtBQUs0RCxJQUFMLENBQVVqRCxFQUFWLENBQWFSLEdBQWIsRUFBM0I7QUFDRCxPQUhNLENBQVA7QUFJRDtBQUNGOztBQXZRdUIsQ0FBMUI7O2tCQTJRZXJCLGlCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDIwIFNwaW5hbENvbSAtIHd3dy5zcGluYWxjb20uY29tXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgU3BpbmFsQ29yZS5cbiAqXG4gKiBQbGVhc2UgcmVhZCBhbGwgb2YgdGhlIGZvbGxvd2luZyB0ZXJtcyBhbmQgY29uZGl0aW9uc1xuICogb2YgdGhlIEZyZWUgU29mdHdhcmUgbGljZW5zZSBBZ3JlZW1lbnQgKFwiQWdyZWVtZW50XCIpXG4gKiBjYXJlZnVsbHkuXG4gKlxuICogVGhpcyBBZ3JlZW1lbnQgaXMgYSBsZWdhbGx5IGJpbmRpbmcgY29udHJhY3QgYmV0d2VlblxuICogdGhlIExpY2Vuc2VlIChhcyBkZWZpbmVkIGJlbG93KSBhbmQgU3BpbmFsQ29tIHRoYXRcbiAqIHNldHMgZm9ydGggdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIHRoYXQgZ292ZXJuIHlvdXJcbiAqIHVzZSBvZiB0aGUgUHJvZ3JhbS4gQnkgaW5zdGFsbGluZyBhbmQvb3IgdXNpbmcgdGhlXG4gKiBQcm9ncmFtLCB5b3UgYWdyZWUgdG8gYWJpZGUgYnkgYWxsIHRoZSB0ZXJtcyBhbmRcbiAqIGNvbmRpdGlvbnMgc3RhdGVkIG9yIHJlZmVyZW5jZWQgaGVyZWluLlxuICpcbiAqIElmIHlvdSBkbyBub3QgYWdyZWUgdG8gYWJpZGUgYnkgdGhlc2UgdGVybXMgYW5kXG4gKiBjb25kaXRpb25zLCBkbyBub3QgZGVtb25zdHJhdGUgeW91ciBhY2NlcHRhbmNlIGFuZCBkb1xuICogbm90IGluc3RhbGwgb3IgdXNlIHRoZSBQcm9ncmFtLlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgbGljZW5zZSBhbG9uZ1xuICogd2l0aCB0aGlzIGZpbGUuIElmIG5vdCwgc2VlXG4gKiA8aHR0cDovL3Jlc291cmNlcy5zcGluYWxjb20uY29tL2xpY2Vuc2VzLnBkZj4uXG4gKi9cblxuaW1wb3J0IHtcbiAgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSxcbiAgU3BpbmFsR3JhcGhTZXJ2aWNlXG59IGZyb20gXCJzcGluYWwtZW52LXZpZXdlci1ncmFwaC1zZXJ2aWNlXCI7XG5pbXBvcnQgeyBBYnN0cmFjdEVsZW1lbnQgfSBmcm9tIFwic3BpbmFsLW1vZGVscy1idWlsZGluZy1lbGVtZW50c1wiO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBNb2RlbCB9IGZyb20gXCJzcGluYWwtY29yZS1jb25uZWN0b3Jqc190eXBlXCI7XG5cbmNvbnN0IEdlb2dyYXBoaWNDb250ZXh0ID0ge1xuICBjb25zdGFudHM6IGNvbnN0YW50cyxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgdHlwZSBvZiB0aGUgdHlwZSBnaXZlbiBhcyBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ2hpbGQgdHlwZVxuICAgKi9cbiAgZ2V0Q2hpbGRUeXBlKHBhcmVudFR5cGUpIHtcbiAgICBsZXQgcGFyZW50VHlwZUluZGV4ID0gY29uc3RhbnRzLkdFT0dSQVBISUNfVFlQRVNfT1JERVIuaW5kZXhPZihcbiAgICAgIHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKHBhcmVudFR5cGVJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zdGFudHMuR0VPR1JBUEhJQ19UWVBFU19PUkRFUltwYXJlbnRUeXBlSW5kZXggKyAxXTtcbiAgfSxcblxuICAvKipcbiAgICogSXQgVGFrZXMgYXMgcGFyYW1ldGVyIGEgY29udGV4dCBuYW1lLCByZXR1cm5zIHRydWUgaWYgYSBjb250ZXh0IHdpdGggdGhlIHNhbWUgbmFtZSBkb2VzIG5vdCBleGlzdCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjcmVhdGVDb250ZXh0KGNvbnRleHROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiY29udGV4dE5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmdldENvbnRleHQoY29udGV4dE5hbWUpO1xuXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDb250ZXh0KGNvbnRleHROYW1lLFxuICAgICAgY29uc3RhbnRzLkNPTlRFWFRfVFlQRSxcbiAgICAgIG5ldyBBYnN0cmFjdEVsZW1lbnQoY29udGV4dE5hbWUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgYXMgcGFyYW1ldGVycyBhIGNvbnRleHQgKFNwaW5hbENvbnRleHQpLCBhIHBhcmVudCBub2RlIChtdXN0IGJlIGEgU3BpbmFsTm9kZSkgYW5kIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWJzdHJhY3QgZWxlbWVudCB0eXBlO1xuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWUgLSBUaGUgQWJzdGFjdEVsZW1lbnQgTmFtZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGFkZEFic3RyYWN0RWxlbWVudChjb250ZXh0LCBub2RlLCBlbGVtZW50TmFtZSkge1xuICAgIGNvbnN0IHBhcmVudFR5cGUgPSBub2RlLnR5cGUuZ2V0KCk7XG4gICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5nZXRDaGlsZFR5cGUocGFyZW50VHlwZSk7XG5cbiAgICBpZiAoIWNoaWxkVHlwZSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGAke3BhcmVudFR5cGV9IGlzIG5vdCBhIHZhbGlkIHR5cGUgaW4gZ2VvZ3JhcGhpYyBjb250ZXh0YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZFJlbGF0aW9uID0gY29uc3RhbnRzLk1BUF9UWVBFX1JFTEFUSU9OLmdldChjaGlsZFR5cGUpO1xuXG4gICAgY29uc3QgY2hpbGROb2RlID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmNyZWF0ZU5vZGUoeyBuYW1lOiBlbGVtZW50TmFtZSwgdHlwZTogY2hpbGRUeXBlIH0sIG5ldyBBYnN0cmFjdEVsZW1lbnQoZWxlbWVudE5hbWUpKTtcbiAgICBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGRJbkNvbnRleHQobm9kZS5pZC5nZXQoKSwgY2hpbGROb2RlLFxuICAgICAgY29udGV4dC5pZC5nZXQoKSwgY2hpbGRSZWxhdGlvbiwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSk7XG5cbiAgICB0aGlzLmFkZFRvUmVmZXJlbmNlQ29udGV4dChjaGlsZE5vZGUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljIElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJZCAtIFRoZSBwYXJlbnQgTm9kZSBJZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnVpbGRpbmdOYW1lIC0gQnVpbGRpbmcgTmFtZVxuICAgKi9cbiAgYWRkQnVpbGRpbmcoY29udGV4dElkLCBwYXJlbnRJZCwgYnVpbGRpbmdOYW1lKSB7XG5cbiAgICBsZXQgbm9kZUlkID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmNyZWF0ZU5vZGUoe1xuICAgICAgbmFtZTogYnVpbGRpbmdOYW1lLFxuICAgICAgdHlwZTogY29uc3RhbnRzLkJVSUxESU5HX1RZUEVcbiAgICB9LCBuZXcgQWJzdHJhY3RFbGVtZW50KGJ1aWxkaW5nTmFtZSkpO1xuXG4gICAgdGhpcy5hZGRUb1JlZmVyZW5jZUNvbnRleHQobm9kZUlkKTtcblxuICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGRJbkNvbnRleHQocGFyZW50SWQsIG5vZGVJZCwgY29udGV4dElkLFxuICAgICAgY29uc3RhbnRzLkJVSUxESU5HX1JFTEFUSU9OLCBTUElOQUxfUkVMQVRJT05fUFRSX0xTVF9UWVBFKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWMgSWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElkIC0gVGhlIHBhcmVudCBOb2RlIElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbG9vck5hbWUgLSB0aGUgZmxvb3IgTmFtZVxuICAgKi9cbiAgYWRkRmxvb3IoY29udGV4dElkLCBwYXJlbnRJZCwgZmxvb3JOYW1lKSB7XG4gICAgbGV0IG5vZGVJZCA9IFNwaW5hbEdyYXBoU2VydmljZS5jcmVhdGVOb2RlKHtcbiAgICAgIG5hbWU6IGZsb29yTmFtZSxcbiAgICAgIHR5cGU6IGNvbnN0YW50cy5GTE9PUl9UWVBFXG4gICAgfSwgbmV3IEFic3RyYWN0RWxlbWVudChmbG9vck5hbWUpKTtcblxuICAgIHRoaXMuYWRkVG9SZWZlcmVuY2VDb250ZXh0KG5vZGVJZCk7XG5cbiAgICByZXR1cm4gU3BpbmFsR3JhcGhTZXJ2aWNlLmFkZENoaWxkSW5Db250ZXh0KHBhcmVudElkLCBub2RlSWQsIGNvbnRleHRJZCxcbiAgICAgIGNvbnN0YW50cy5GTE9PUl9SRUxBVElPTiwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWMgSWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElkIC0gVGhlIHBhcmVudCBOb2RlIElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaXRlTmFtZSAtIHRoZSBzaXRlIE5hbWVcbiAgICovXG4gIGFkZFNpdGUoY29udGV4dElkLCBwYXJlbnRJZCwgc2l0ZU5hbWUpIHtcblxuICAgIGxldCBub2RlSWQgPSBTcGluYWxHcmFwaFNlcnZpY2UuY3JlYXRlTm9kZSh7XG4gICAgICBuYW1lOiBzaXRlTmFtZSxcbiAgICAgIHR5cGU6IGNvbnN0YW50cy5TSVRFX1RZUEVcbiAgICB9LCBuZXcgQWJzdHJhY3RFbGVtZW50KHNpdGVOYW1lKSk7XG5cbiAgICB0aGlzLmFkZFRvUmVmZXJlbmNlQ29udGV4dChub2RlSWQpO1xuXG4gICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDaGlsZEluQ29udGV4dChwYXJlbnRJZCwgbm9kZUlkLCBjb250ZXh0SWQsXG4gICAgICBjb25zdGFudHMuU0lURV9SRUxBVElPTiwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWMgSWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElkIC0gVGhlIHBhcmVudCBOb2RlIElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lTmFtZSAtIFpvbmUgbmFtZVxuICAgKi9cbiAgYWRkWm9uZShjb250ZXh0SWQsIHBhcmVudElkLCB6b25lTmFtZSkge1xuICAgIGxldCBub2RlSWQgPSBTcGluYWxHcmFwaFNlcnZpY2UuY3JlYXRlTm9kZSh7XG4gICAgICBuYW1lOiB6b25lTmFtZSxcbiAgICAgIHR5cGU6IGNvbnN0YW50cy5aT05FX1RZUEVcbiAgICB9LCBuZXcgQWJzdHJhY3RFbGVtZW50KHpvbmVOYW1lKSk7XG5cbiAgICB0aGlzLmFkZFRvUmVmZXJlbmNlQ29udGV4dChub2RlSWQpO1xuXG4gICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDaGlsZEluQ29udGV4dChwYXJlbnRJZCwgbm9kZUlkLCBjb250ZXh0SWQsXG4gICAgICBjb25zdGFudHMuWk9ORV9SRUxBVElPTiwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSk7XG5cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkIC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SWQgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21OYW1lIC0gUm9vbSBOYW1lXG4gICAqL1xuICBhZGRSb29tKGNvbnRleHRJZCwgcGFyZW50SWQsIHJvb21OYW1lKSB7XG4gICAgbGV0IG5vZGVJZCA9IFNwaW5hbEdyYXBoU2VydmljZS5jcmVhdGVOb2RlKHtcbiAgICAgIG5hbWU6IHJvb21OYW1lLFxuICAgICAgdHlwZTogY29uc3RhbnRzLlJPT01fVFlQRVxuICAgIH0sIG5ldyBBYnN0cmFjdEVsZW1lbnQocm9vbU5hbWUpKTtcblxuICAgIHRoaXMuYWRkVG9SZWZlcmVuY2VDb250ZXh0KG5vZGVJZCk7XG5cbiAgICByZXR1cm4gU3BpbmFsR3JhcGhTZXJ2aWNlLmFkZENoaWxkSW5Db250ZXh0KHBhcmVudElkLCBub2RlSWQsIGNvbnRleHRJZCxcbiAgICAgIGNvbnN0YW50cy5ST09NX1JFTEFUSU9OLCBTUElOQUxfUkVMQVRJT05fUFRSX0xTVF9UWVBFKTtcbiAgfSxcblxuICAvKipcbiAgICogaXQgdXNlcyBiaW1PYmplY3Qgc2VydmljZSB0byBhZGQgYWxsIGRiSWRzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzLlxuICAgKiB0aGUgcGFyYW1ldGVyIGRiSWRzIGNhbiBiZSBhIHNpbXBsZSBkYklkcyBvciBhIGxpc3Qgb2YgZGJJZHMuXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQXJyYXk8TnVtYmVyPn0gZGJJZHMgLSBDYW4gYmVcbiAgICovXG4gIGFkZEJpbUVsZW1lbnQoY29udGV4dCwgbm9kZSwgZGJJZHMsIG1vZGVsKSB7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGJJZHMpKSBkYklkcyA9IFtkYklkc107XG5cblxuICAgIC8vIGxlIGJpbU9iamVjdFNlcnZpY2VcbiAgICAvLyBsZXQgYyA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRSZWFsTm9kZShjb250ZXh0LmlkLmdldCgpKTtcbiAgICAvLyBsZXQgbiA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRSZWFsTm9kZShub2RlLmlkLmdldCgpKTtcblxuICAgIGxldCBjb250ZXh0SWQgPSBjb250ZXh0LmlkLmdldCgpO1xuICAgIGxldCBwYXJlbnRJZCA9IG5vZGUuaWQuZ2V0KCk7XG5cbiAgICBkYklkcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgLy8gYmltb2JqU2VydmljZS5hZGRCSU1PYmplY3QoYywgbiwgZWxlbWVudC5kYklkLCBlbGVtZW50Lm5hbWUpO1xuICAgICAgd2luZG93LnNwaW5hbC5CaW1PYmplY3RTZXJ2aWNlLmFkZEJJTU9iamVjdChjb250ZXh0SWQsIHBhcmVudElkLFxuICAgICAgICBlbGVtZW50LmRiSWQsXG4gICAgICAgIGVsZW1lbnQubmFtZSwgbW9kZWwpO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgX2dldFJlZmVyZW5jZUNvbnRleHROYW1lKG5vZGVJZCkge1xuICAgIGxldCBub2RlID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmdldEluZm8obm9kZUlkKTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlLmdldCgpKSB7XG4gICAgICBjYXNlIGNvbnN0YW50cy5TSVRFX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLlNJVEVfUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgcmVsYXRpb246IGNvbnN0YW50cy5TSVRFX1JFTEFUSU9OXG4gICAgICAgIH07XG4gICAgICBjYXNlIGNvbnN0YW50cy5CVUlMRElOR19UWVBFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGNvbnN0YW50cy5CVUlMRElOR19SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLkJVSUxESU5HX1JFTEFUSU9OXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgY29uc3RhbnRzLkZMT09SX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLkZMT09SX1JFRkVSRU5DRV9DT05URVhULFxuICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuRkxPT1JfUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBjb25zdGFudHMuWk9ORV9UWVBFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGNvbnN0YW50cy5aT05FX1JFRkVSRU5DRV9DT05URVhULFxuICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuWk9ORV9SRUxBVElPTlxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGNvbnN0YW50cy5ST09NX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLlJPT01fUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgcmVsYXRpb246IGNvbnN0YW50cy5ST09NX1JFTEFUSU9OXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbm9kZUlkXG4gICAqL1xuICBhZGRUb1JlZmVyZW5jZUNvbnRleHQobm9kZUlkKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMuX2dldFJlZmVyZW5jZUNvbnRleHROYW1lKG5vZGVJZCk7XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbGV0IGNvbnRleHQgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0Q29udGV4dChvYmoubmFtZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gU3BpbmFsR3JhcGhTZXJ2aWNlLmFkZENoaWxkKGNvbnRleHQuaW5mby5pZC5nZXQoKSwgbm9kZUlkLFxuICAgICAgICAgIG9iai5yZWxhdGlvbixcbiAgICAgICAgICBTUElOQUxfUkVMQVRJT05fUFRSX0xTVF9UWVBFKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDb250ZXh0KG9iai5uYW1lLCBvYmoubmFtZS5yZXBsYWNlKFwiLlwiLCBcIlwiKSwgbmV3IE1vZGVsKHsgbmFtZTogb2JqLm5hbWUgfSkpXG4gICAgICAgIC50aGVuKGMgPT4ge1xuICAgICAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGQoYy5pbmZvLmlkLmdldCgpLCBub2RlSWQsIG9iai5yZWxhdGlvbiwgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICB9XG5cbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZFxuICAgKi9cbiAgYWRkQ29udGV4dFRvUmVmZXJlbmNlKGNvbnRleHRJZCkge1xuICAgIGxldCBjb250ZXh0ID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmdldFJlYWxOb2RlKGNvbnRleHRJZCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmZvckVhY2goY29uc3RhbnRzLkdFT0dSQVBISUNfUkVMQVRJT05TLCAobm9kZSkgPT4ge1xuICAgICAgICBTcGluYWxHcmFwaFNlcnZpY2UuX2FkZE5vZGUobm9kZSk7XG4gICAgICAgIHRoaXMuYWRkVG9SZWZlcmVuY2VDb250ZXh0KG5vZGUuaW5mby5pZC5nZXQoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvZ3JhcGhpY0NvbnRleHQ7XG4iXX0=